'''Бінарний пошук'''

# У даній задачі задано 2 масива, та 2 шуканих елемента. Перший масив задано попередньо, і шуканий елемент (45) завжди буде знаходитись на позиції 5.\
# Другий масив задано рандомно, тобто шуканий елемент (3) може бути у масиві, або ж бути відсутнім у ньому.

import numpy as np # імпортуємо бібліотеку NumPy
import random # імпортуємо бібліотеку random

while True:
    A = np.array((1, 3, 8, 11, 18, 45))  # задаємо масив А за допомогою функції array з бібліотеки numpy
    x = 45  # задаємо перший шуканий елемент
    B = np.zeros(5, dtype=int)  # ініціалізуємо масив В, заповнюючи його нулями
    y = 3  # задаємо другий шуканий елемент
    for i in range(5):
        B[i] = random.randint(0, 5) # рандомно задаємо значення елементів масиву В
    B = sorted(B) # сортуємо елементи масиву, бо це необхідна умова для бінарного пошуку

    print('Масив А:\n', A) # виводимо масив А
    print() # відступ
    print('Масив B:\n', B) # виводимо масив В
    print() # відступ

    L_A = 0 # задаємо крайню ліву позицію для масива А
    R_A = len(A) - 1 # задаємо крайню праву позицію для масива А
    k_A = 0 # задаємо змінну, що буде відповідати за середину масиву А
    flag_A = False # задаємо flag для припинення циклу

    L_B = 0 # задаємо крайню ліву позицію для масива В
    R_B = len(B) - 1 # задаємо крайню праву позицію для масива В
    k_B = 0 # задаємо змінну, що буде відповідати за середину масиву В
    flag_B = False # задаємо flag для припинення циклу

    count1 = 0 # змінна для визначення кількості порівнянь шуканого елемента у масиві А
    count2 = 0 # змінна для визначення кількості порівнянь шуканого елемента у масиві B
    
    while (L_A <= R_A and not flag_A):
        k_A = (L_A + R_A) // 2 # шукаємо "золоту середину" масиву А
        if(A[k_A] == x): # якщо середній елемент масиву = шуканому елементу, то k - позиція шуканого елемента
            count1 += 1
            flag_A = True
        elif(A[k_A] < x): # якщо середній елемент масиву менший від шуканого, то шуканий елемент буде знаходитись зправа, тобто можна посунути ліву межу
            count1 += 1
            L_A = k_A + 1
        else:
            count1 += 1
            R_A = k_A - 1 # якщо середній елемент масиву більший від шуканого, то шуканий елемент буде знаходитись зліва, тобто можна посунути праву межу
            
    while (L_B <= R_B and not flag_B): # робимо те ж саме для масиву B
        k_B = (L_B + R_B) // 2
        if(B[k_B] == y):
            count2 += 1
            flag_B = True
        elif(B[k_B] < y):
            count2 += 1
            L_B = k_B + 1
        else:
            count2 += 1
            R_B = k_B - 1

    if not flag_A: # якщо flag не змінився, то елемент не був знайдений у масиві.
        print(f'Елемент {x} не знайдений у масиві А.')
        print(f'Кількість порівнянь: {count1}.') # виводимо кількість порівнянь
    else:
        print(f'Елемент {x} знайдений на позиції {k_A} у масиві А.') # інакше - елемент знаходиться на позиції k
        print(f'Кількість порівнянь: {count1}.')

    print()
    if not flag_B: # робимо те ж саме для масиву В
        print(f'Елемент {y} не знайдений у масиві В.')
        print(f'Кількість порівнянь: {count2}.')
    else:
        print(f'Елемент {y} знайдений на позиції {k_B} у масиві В.')
        print(f'Кількість порівнянь: {count2}.')

    print()
    print('Бажаєте повторити задачу?') # питаємо чи бажає користувач повторити задачу
    while True:
        question = input('(Так/Ні): ')
        if (
                question == 'Так' or question == 'так' or question == 'Yes' or question == 'yes' or question == 'y' or question == '+'):
            print()
            break
        elif (
                question == 'Ні' or question == 'ні' or question == 'No' or question == 'no' or question == 'n' or question == '-'):
            exit(0)
        else:
            print()
            print('Бажаєте повторити задачу?')
